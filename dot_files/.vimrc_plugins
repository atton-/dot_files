" vim: set filetype=vim:
" plugins settings
" plugins management plugin : neobundle

" neobundle Settings {{{
filetype off
" neobundle initialize {{{
if has('vim_starting')
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif
call neobundle#rc(expand('~/.vim/bundle/'))
" }}}

" set use plugins

" plugin management
NeoBundle 'Shougo/neobundle.vim'

" neocomplcache
NeoBundle 'Shougo/neocomplcache.git'
NeoBundle 'Shougo/neosnippet'
NeoBundleLazy 'neco-look'         , {'autoload' : {'filetypes' : 'text'}}

" quickrun and watchdogs
NeoBundle 'thinca/vim-quickrun'
NeoBundle 'osyo-manga/vim-watchdogs'
NeoBundle 'osyo-manga/shabadou.vim'

" extension
NeoBundle 'Shougo/unite.vim'
NeoBundle 'h1mesuke/unite-outline'
NeoBundle 'kmnk/vim-unite-giti'
NeoBundle 'thinca/vim-ref'
NeoBundle 'tyru/eskk.vim'
NeoBundleLazy 'Shougo/vimshell.git'    , {'autoload' : {'commands' : ['VimShell', 'VimShellTab']}}
NeoBundleLazy 'sjl/gundo.vim'          , {'autoload' : {'commands' : 'GundoToggle'}}
NeoBundleLazy 'gregsexton/VimCalc'     , {'autoload' : {'commands' : 'Calc'}}

" utility
NeoBundle 'thinca/vim-textobj-between' , {'depends' : 'textobj-user'}
NeoBundle 'tpope/vim-surround'
NeoBundle 'matchit.zip'
NeoBundleLazy 'h1mesuke/vim-alignta'   , {'autoload' : {'commands'  : ['Alignta', 'Align']}}
NeoBundleLazy 'atton-/a.vim'           , {'autoload' : {'filetypes' : ['c', 'cpp']}}

" syntax
NeoBundleLazy 'dag/vim2hs' , {'autoload' : {'filetypes' : 'haskell'}}

" auto make vimproc
NeoBundle 'Shougo/vimproc', {
            \ 'build' : {
            \     'windows' : 'echo "Sorry, cannot update vimproc binary file in Windows."',
            \     'cygwin' : 'make -f make_cygwin.mak',
            \     'mac' : 'make -f make_mac.mak',
            \     'unix' : 'make -f make_unix.mak',
            \    },
            \ }

" lazy load plugins
NeoBundleLazy 'yuratomo/w3m.vim'
NeoBundleLazy 'Shougo/vinarise'
NeoBundleLazy 'tpope/vim-rails'
NeoBundleLazy 'taka84u9/vim-ref-ri'
NeoBundleLazy 'ujihisa/ref-hoogle'

" for debug
NeoBundleLazy 'thinca/vim-prettyprint'

" check not installed plugin {{{
if neobundle#exists_not_installed_bundles()
    echomsg 'Not installed bundles : ' .
                \ string(neobundle#get_not_installed_bundle_names())
    echomsg 'Please execute ":NeoBundleInstall" command.'
endif
" }}}
" }}}

" plugins settings {{{


" neocomplcache
let g:neocomplcache_enable_at_startup = 1                   " enable on startup
let g:neocomplcache_enable_underbar_completion = 1          " enable '_' completion
let g:neocomplcache_temporary_dir = expand('~/.vim/.neocon')

" manual completion on neocomplcache : i_^x^g
inoremap <expr><c-x><c-g> neocomplcache#start_manual_complete()


" neosnippet

" snippet mapping : ^k
imap <C-k> <Plug>(neosnippet_expand_or_jump)
smap <C-k> <Plug>(neosnippet_expand_or_jump)

" my snnipets dir
let g:neosnippet#snippets_directory = expand("~/.vim/snippets")


" vimshell
let g:vimshell_interactive_update_time = 10
let g:vimshell_prompt       = '% '
let g:vimshell_user_prompt  = ''
let g:vimshell_right_prompt = 'getcwd()'
let g:vimshell_temporary_directory = expand('~/.vim/.vimshell')

augroup VimShell
    autocmd!
    autocmd FileType vimshell setlocal nonumber
augroup END
" command for shortcut
command! Vsh VimShellTab


" Unite
let g:unite_update_time         = 10
let g:unite_data_directory      = expand('~/.vim/.unite')
let g:unite_enable_start_insert = 1

" Shortcut Commands
command! Ub Unite buffer
command! Uf Unite file
command! Ur Unite register
command! Um Unite file_mru
command! Ug Unite grep
command! Uo Unite outline
command! Uc Unite menu:commands
command! Uv Unite giti

" Shortcut Mappings
nnoremap <Leader>b :Unite buffer<CR>
nnoremap <Leader>f :Unite file<CR>
nnoremap <Leader>r :Unite register<CR>
nnoremap <Leader>m :Unite file_mru<CR>
nnoremap <Leader>g :Unite grep<CR>
nnoremap <Leader>o :Unite outline<CR>
nnoremap <Leader>c :Unite menu:commands<CR>
nnoremap <Leader><Leader> :Unite menu:commands<CR>
nnoremap <Leader>v :Unite giti<CR>

" commands source. for command shortcut {{{

" command map
let s:commands = {}
function! s:commands.map(key, value)
    return { 'word': a:key, 'kind': 'command', 'action__command': a:value}
endfunction

" commands
let s:commands.candidates = {
\ 'NeoBundleUpdate'  : 'NeoBundleUpdate',
\ 'NeoBundleSource'  : 'NeoBundleSource',
\ 'ReloadVimrc'      : 'ReloadVimrc',
\ 'EditVimrc'        : 'EditVimrc',
\ 'EditVimrcPlugins' : 'EditVimrcPlugins',
\ 'ToggleLastStatus' : 'ToggleLastStatus',
\ 'ToggleWildIgnore' : 'ToggleWildIgnore',
\ }

" add unite
let g:unite_source_menu_menus = {'commands': deepcopy(s:commands)}

unlet s:commands
" }}}


" quickrun
" shortcut
nmap <C-k> <Plug>(quickrun)
" disable default mappings
let g:quickrun_no_default_key_mappings = 1
" init default settings
let g:quickrun_config = {'_' : {}}
" horizontal split on quickrun
let g:quickrun_config._['split'] = ''
" vimproc updatetime
let g:quickrun_config._['runner']                    = 'vimproc'
let g:quickrun_config._['runner/vimproc/updatetime'] = 50
" scheme settings (for SICP)
let g:quickrun_config.scheme = {'command' : 'gosh' , 'cmdopt' : '-i' , 'exec' : '%c %o < %s'}

" shabadou hooks
" for all : if output is empty, close quickrun buffer and echo message(finished point)
let g:quickrun_config._['hook/close_buffer/enable_empty_data'] = 1
let g:quickrun_config._['hook/echo/enable']                    = 1
let g:quickrun_config._['hook/echo/output_finish']             = 'quickrun finised.'

" watchdogs
" default settings
let s:watchdogs_config = {}
" for unnammed buffer
let s:watchdogs_config['hook/quickfix_replate_tempname_to_bufnr/enable_exit']   = 1
let s:watchdogs_config['hook/quickfix_replate_tempname_to_bufnr/priority_exit'] = -10

" for LaTeX {{{
let g:quickrun_config['tex/watchdogs_checker'] = {
            \'type' : 'watchdogs_checker/tex' }
let g:quickrun_config['watchdogs_checker/tex'] = {
        \'command' : 'lacheck',
        \'exec' : '%c %s',
        \
        \'quickfix/errorformats' :
            \'%E!\ LaTeX\ %trror:\ %m,'
            \.'%E!\ %m,'
            \.'%+WLaTeX\ %.%#Warning:\ %.%#line\ %l%.%#,'
            \.'%+W%.%#\ at\ lines\ %l--%*\\d,'
            \.'%WLaTeX\ %.%#Warning:\ %m,'
            \.'%Cl.%l\ %m,'
            \.'%+C\ \ %m.,'
            \.'%+C%.%#-%.%#,'
            \.'%+C%.%#[]%.%#,'
            \.'%+C[]%.%#,'
            \.'%+C%.%#%[{}\\]%.%#,'
            \.'%+C<%.%#>%.%#,'
            \.'%C\ \ %m,'
            \.'%-GSee\ the\ LaTeX%m,'
            \.'%-GType\ \ H\ <return>%m,'
            \.'%-G\ ...%.%#,'
            \.'%-G%.%#\ (C)\ %.%#,'
            \.'%-G(see\ the\ transcript%.%#),'
            \.'%-G\\s%#,'
            \.'%+O(%*[^()])%r,'
            \.'%+O%*[^()](%*[^()])%r,'
            \.'%+P(%f%r,'
            \.'%+P\ %\\=(%f%r,'
            \.'%+P%*[^()](%f%r,'
            \.'%+P[%\\d%[^()]%#(%f%r,'
            \.'%+Q)%r,'
            \.'%+Q%*[^()])%r,'
            \.'%+Q[%\\d%*[^()])%r' }
" }}}

" add to quickrun_config
let g:quickrun_config['watchdogs_checker/_']  = s:watchdogs_config
unlet s:watchdogs_config
" watchdogs initialize
call watchdogs#setup(g:quickrun_config)
" shortcut
nnoremap <C-j> :WatchdogsRunSilent<CR>


" VimCalc
let g:VCalc_WindowPosition = 'bottom'                       " show buttom


" eskk.vim
let g:eskk#directory  = expand('~/.vim/eskk')               " direcotry
let g:eskk#dictionary = { 'path': expand('~/.vim/eskk/skk-jisyo'), 'sorted': 0, 'encoding': 'utf-8' }       " dictionary
let g:eskk#large_dictionary = { 'path': expand('~/.vim/eskk/SKK-JISYO.L'), 'sorted': 1, 'encoding': 'euc-jp', }
imap <C-J> <Plug>(eskk:enable)
cmap <C-J> <Plug>(eskk:enable)
lmap <C-J> <Plug>(eskk:enable)

" vim-ref
let g:ref_cache_dir = expand('~/.vim/.vim_ref_cache')

" webdict
augroup Ref
" if FileType is 'text', use webdict source
    autocmd!
    autocmd FileType text call ref#register_detection('_', 'webdict')
augroup END
" webdict source use yahoo_dict and infoseek and wikipedia:w
let g:ref_source_webdict_sites = {
\ 'yahoo_dict'  : {'url' : 'http://dic.search.yahoo.co.jp/search?p=%s',  'line' : '47'},
\ 'infoseek_je' : {'url' : 'http://dictionary.infoseek.ne.jp/jeword/%s', 'line' : '11'},
\ 'infoseek_ej' : {'url' : 'http://dictionary.infoseek.ne.jp/ejword/%s', 'line' : '11'},
\ 'wikipedia'   : {'url' : 'http://ja.wikipedia.org/wiki/%s',},}
" webdict default dictionary is yahoo_dict
let g:ref_source_webdict_sites.default = 'yahoo_dict'
" text browser is w3m
let g:ref_source_webdict_cmd = 'w3m -dump %s'

" refe
let g:ref_refe_cmd = expand('~/.vim/ruby_ref/ruby-refm-1.9.3-dynamic-20120829/refe-1_9_3 ')


" gundo.vim
" UndoTree : U
nnoremap U :GundoToggle<CR>

" vim-surround
" manual mapping for eskk.vim (ignore ISurruond)
let g:surround_no_mappings = 1
" diff original mapping : Visual mode surround use 's' (original 'S')
if has('vim_starting')
    nmap ds  <Plug>Dsurround
    nmap cs  <Plug>Csurround
    nmap ys  <Plug>Ysurround
    nmap yS  <Plug>YSurround
    nmap yss <Plug>Yssurround
    nmap ySs <Plug>YSsurround
    nmap ySS <Plug>YSsurround
    xmap s   <Plug>VSurround
    xmap gs  <Plug>VgSurround
endif


" alignta.vim
let g:alignta_default_arguments = " = "
vnoremap <Leader>= :Alignta = <CR>
vnoremap <Leader>: :Alignta : <CR>


" w3m.vim
augroup W3m
    autocmd!
    " type 'K', use webdict on ref
    autocmd FileType w3m call ref#register_detection('_', 'webdict')
    autocmd FileType w3m set nonumber
augroup END

" }}}
